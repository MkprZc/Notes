（文档：
    基于redis实现分布式锁_Go工程师体系课全新版
    redlock详解_Go工程师体系课全新版
    ）

## 基于redis实现分布式锁
(开源项目：https://github.com/go-redsync/redsync)


（内容缺失）
将获取和设置值变成原子性的操作

2、如果我的服务挂掉了- 死锁
    1. 设置过期时间
    2. 如果你设置了过期时间，那么如果过期时间到了我的业务逻辑没有执行完怎么办？
        1. 在过期之前刷新一下
        2. 需要自己去启动协程完成延时的工作
            1. 延时的接口可能会带来负面影响 - 如果其中某一个服务hung住了， 2s就能执行完，但是你hung住那么你就会一直去申请延长锁，导致别人永远获取不到锁，这个很要命

3、分布锁需要解决的问题 - lua脚本去做
    1. 互斥性 - setnx
    2. 死锁
    3. 安全性
        1. 锁只能被持有该锁的用户删除，不能被其他用户删除
            1. 当时设置的value值是多少只有当时的g才能知道
            2. 在删除的时取出redis中的值和当前自己保存下来的值对比一下

4、即使你这样实现了分布式但是还是会有问题 - redlock



### 基于redis的分布式锁在集群中的问题

多节点redis实现的分布式锁算法(RedLock):有效防止单点故障
假设有5个完全独立的redis主服务器
    1.获取当前时间戳
    2.client尝试按照顺序使用相同的key,value获取所有redis服务的锁，在获取锁的过程中的获取时间比锁过期时间短很多，这是为了不要过长时间等待已经关闭的redis服务。并且试着获取下一个redis实例。
    比如：TTL为5s,设置获取锁最多用1s，所以如果一秒内无法获取锁，就放弃获取这个锁，从而尝试获取下个锁
    3.client通过获取所有能获取的锁后的时间减去第一步的时间，这个时间差要小于TTL时间并且至少有3个redis实例成功获取锁，才算真正的获取锁成功
    4.如果成功获取锁，则锁的真正有效时间是 TTL减去第三步的时间差 的时间；比如：TTL 是5s,获取所有锁用了2s,则真正锁有效时间为3s(其实应该再减去时钟漂移);
    5.如果客户端由于某些原因获取锁失败，便会开始解锁所有redis实例；因为可能已经获取了小于3个锁，必须释放，否则影响其他client获取锁


什么是时钟漂移
如果redis服务器的机器时钟发生了向前跳跃，就会导致这个key过早超时失效，比如说客户端1拿到锁后，key的过期时间是12:02分，但redis服务器本身的时钟比客户端快了2分钟，导致key在12:00的时候就失效了，这时候，如果客户端1还没有释放锁的话，就可能导致多个客户端同时持有同一把锁的问题


RedLock算法是否是异步算法？？
可以看成是同步算法；因为 即使进程间（多个电脑间）没有同步时钟，但是每个进程时间流速大致相同；并且时钟漂移相对于TTL叫小，可以忽略，所以可以看成同步算法；（不够严谨，算法上要算上时钟漂移，因为如果两个电脑在地球两端，则时钟漂移非常大）


RedLock失败重试
当client不能获取锁时，应该在随机时间后重试获取锁；并且最好在同一时刻并发的把set命令发送给所有redis实例；而且对于已经获取锁的client在完成任务后要及时释放锁，这是为了节省时间；


RedLock释放锁
由于释放锁时会判断这个锁的value是不是自己设置的，如果是才删除；所以在释放锁时非常简单，只要向所有实例都发出释放锁的命令，不用考虑能否成功释放锁；


系统有活性的三个特征
1.能够自动释放锁
2.在获取锁失败（不到一半以上），或任务完成后 能够自动释放锁，不用等到其自动过期
3.在client重试获取锁前（第一次失败到第二次重试时间间隔）大于第一次获取锁消耗的时间；
4.重试获取锁要有一定次数限制


RedLock性能及崩溃恢复的相关解决方法
1.如果redis没有持久化功能，在clientA获取锁成功后，所有redis重启，clientB能够再次获取到锁，这样违法了锁的排他互斥性;
2.如果启动AOF永久化存储，事情会好些， 举例:当我们重启redis后，由于redis过期机制是按照unix时间戳走的，所以在重启后，然后会按照规定的时间过期，不影响业务;但是由于AOF同步到磁盘的方式默认是每秒-次，如果在一秒内断电，会导致数据丢失，立即重启会造成锁互斥性失效;但如果同步磁盘方式使用Always(每一个写命令都同步到硬盘)造成性能急剧下降;所以在锁完全有效性和性能方面要有所取舍;
3.有效解决既保证锁完全有效性及性能高效及即使断电情况的方法是redis同步到磁盘方式保持默认的每秒，在redis无论因为什么原因停掉后要等待TTL时间后再重启(学名:延迟重启) ;缺点是 在TTL时间内服务相当于暂停状态;


总结：
1.TTL时长 要大于正常业务执行的时间+获取所有redis服务消耗时间+时钟漂移
2.获取redis所有服务消耗时间要 远小于TTL时间，并且获取成功的锁个数要 在总数的一般以上:N/2+1
3.尝试获取每个redis实例锁时的时间要 远小于TTL时间
4.尝试获取所有锁失败后 重新尝试一定要有一定次数限制
5.在redis崩溃后（无论一个还是所有），要延迟TTL时间重启redis
6.在实现多redis节点时要结合单节点分布式锁算法 共同实现






（文档：https://cloud.tencent.com/developer/article/2321395）

青铜方案：
    缺陷：业务代码出现异常或者服务器宕机，没有执行主动删除锁的逻辑，就造成了死锁。
    改进：设置锁的自动过期时间，过一段时间后，自动删除锁，这样其他线程就能获取到锁了。

白银方案：
    缺陷：占锁和设置锁过期时间是分步两步执行的，不是原子操作。
    改进：占锁和设置锁过期时间保证原子操作。

黄金方案：
    缺陷：主动删除锁时，因锁的值都是相同的，将其他客户端占用的锁删除了。
    改进：每次占用的锁，随机设为较大的值，主动删除锁时，比较锁的值和自己设置的值是否相等。

铂金方案：
    缺陷：获取锁、比较锁的值、删除锁，这三步是非原子性的。中途又可能锁自动过期了，又被其他客户端抢占了锁，导致删锁时把其他客户端占用的锁删了。
    改进：使用 Lua 脚本进行获取锁、比较锁、删除锁的原子操作。

钻石方案：
    缺陷：非专业的分布式锁方案。
    改进：Redisson 分布式锁。



（文档：https://cloud.tencent.com/developer/article/2002625）

Redisson还实现了Redis文档中提到像分布式锁Lock这样的更高阶应用场景。事实上Redisson并没有不止步于此，在分布式锁的基础上还提供了联锁（MultiLock），读写锁（ReadWriteLock），公平锁（Fair Lock），红锁（RedLock），信号量（Semaphore），可过期性信号量（PermitExpirableSemaphore）和闭锁（CountDownLatch）这些实际当中对多线程高并发应用至关重要的基本部件。正是通过实现基于Redis的高阶应用方案，使Redisson成为构建分布式系统的重要工具。（项目地址：https://github.com/redisson/redisson）


Redisson 分布式可重入锁
（1）多个线程抢占锁，后面锁需要等待吗？
    Redisson 的可重入锁（lock）是阻塞其他线程的，需要等待其他线程释放的
（2）如果抢占到锁的线程所在的服务停了，锁会不会被释放？
    如果线程 A 在等待的过程中，服务突然停了，那么锁会释放吗？如果不释放的话，就会成为死锁，阻塞了其他线程获取锁。
    Redisson 在停机后，占用的锁会自动释放（看门狗原理）


看门狗原理
1、如果负责储存这个分布式锁的 Redisson 节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。
2、默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定。
3、如果我们未制定 lock 的超时时间，就使用 30 秒作为看门狗的默认时间。只要占锁成功，就会启动一个定时任务：每隔 10 秒重新给锁设置过期的时间，过期时间为 30 秒。
4、当服务器宕机后，因为锁的有效期是 30 秒，所以会在 30 秒内自动解锁。（30秒等于宕机之前的锁占用时间+后续锁占用的时间）

如果设置了锁的自动过期时间，则执行业务的时间一定要小于锁的自动过期时间，否则手动释放锁将会报错


Redisson 分布式可重入读写锁
写锁是一个排他锁（互斥锁），读锁是一个共享锁。
    读锁 + 读锁：相当于没加锁，可以并发读。
    读锁 + 写锁：写锁需要等待读锁释放锁。
    写锁 + 写锁：互斥，需要等待对方的锁释放。
    写锁 + 读锁：读锁需要等待写锁释放。


Redisson 分布式信号量
关于信号量的使用大家可以想象一下这个场景，有三个停车位，当三个停车位满了后，其他车就不停了。可以把车位比作信号，现在有三个信号，停一次车，用掉一个信号，车离开就是释放一个信号

